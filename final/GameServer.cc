using namespace std;
#include "GameServer.h"

#include <time.h>


GameServer::GameServer(Level *newlevel, int max_pacmen, int max_ghosts, int num_AI, int gametype){
  packillbonus = ghostkillbonus = 100;
  pacdeathpenalty = ghostdeathpenalty = -50;
  theGame = new ServerGameboard(newlevel, this);
  defaultRules = new GameRules();
  currentRules[0] = defaultRules;
  int portnum = 42; // what should the portnum be?
  socket = new RUDP(portnum);
  clientads = new sockaddr_in*[16];
  numclients = 0;
  max_pac = max_pacmen;
  max_gh = max_ghosts;
  num_aigh = num_AI;
  mode = gametype;
  AIplayerlist = new Player*[num_aigh];
  for(int i = 0; i < num_aigh; i++)
    {
    AIplayerlist[i] = new AIGhost(i);
    // i will be used to make some variety in the AI ghosts
    theGame->addPlayer(AIplayerlist[i], 1);
    }
  numRules = 0;
  RunGame();
}

GameServer::~GameServer()
{
  delete theGame;
  delete defaultRules;
  for(int i; i < num_aigh; i++)
    {
      delete AIplayerlist[i];
      AIplayerlist[i] = 0;
    }
  theGame = 0;
  defaultRules = 0;
  delete AIplayerlist;
  AIplayerlist = 0;
}

// Called by the CanIMove function when a player requests a move 
// into an occupied space 
bool GameServer::Collision( Player* firstplayer, Player* secondplayer) {
  bool first = firstplayer->isAGhost();
  bool second = secondplayer->isAGhost();
  int result = 0;
  bool canmove = false;
  Player *eaten;
  eaten = 0;
  UDPacket *death;
  death = new UDPacket();
  byte dying[2];
  // In the calls to the GameRules collision function, 'false' represents a pacman and 'true' represents a ghost.  This function will return a 1 if the first player may eat the second, a 2 if the second player may eat the first, a 3 if the first player is blocked by the second, and a 4 if they may pass through each other.
  result = currentMechanics->collision(first, second); 
  
  // need a case statement for actions for different results
  if(result == 1)
    {
      theGame->EatPlayer(firstplayer, secondplayer);
      eaten = secondplayer;
      if(first)
	{
	  changeScore(firstplayer, ghostkillbonus);
	  changeScore(secondplayer, pacdeathpenalty);
	}
      else
	{
	  changeScore(firstplayer, packillbonus);
	  changeScore(secondplayer, ghostdeathpenalty);
	}
    }
  if(result == 2)
    {
      theGame->EatPlayer(secondplayer, firstplayer);
      eaten = firstplayer;
      if(first)
	{
	  changeScore(firstplayer, ghostdeathpenalty);
	  changeScore(secondplayer, packillbonus);
	}
      else
	{
	  changeScore(firstplayer, pacdeathpenalty);
	  changeScore(secondplayer, ghostkillbonus);
	}
    }
  if(eaten)
    {
      dying[0] = (char)3;
      dying[1] = (char)(eaten->getPlayerID());
      death->setData(dying, 2);
      for(int i = 0; i < numclients; i++)
	{
	  death->setAddress(clientads[i]);
	  socket->sendReliable(death);
	}
    }

  if(result != 3)
    canmove = true;
  return canmove;
}

void GameServer::changeScore(Player *who, int amount)
{
    who->changeScore(amount);
    UDPacket *score;
    score = new UDPacket();
    byte scoreinfo[5];
    scoreinfo[0] = (char)4;
    scoreinfo[1] = (char)(who->getPlayerID());
    if(amount >= 0)
      scoreinfo[2] = (char)0;
    else
      scoreinfo[2] = (char)1;
    scoreinfo[3] = (char)(amount / 100);
    scoreinfo[4] = (char)(amount % 100);
    score->setData(scoreinfo, 5);
    for(int i = 0; i < numclients; i++)
      {
	score->setAddress(clientads[i]);
	socket->sendReliable(score);
      }
}

// Registers an EventListener with the server, so that when events 
// are
// generated by the server, they are given to listener as well 
// as any
// others that have been registered. 
//void GameServer::addListener( EventListener* listener ) {
//
//}

// Request to move into the specified space 
bool GameServer::CanIMove( Player* who, Space* where ) {
  int numplayers = where->getNumPlayers();
  BaseItem* item = where->getItem(); 
  bool canmove = true;
  if(numplayers > 0)
    {
      Player** playershere = new Player*[numplayers];
      playershere = where->getPlayers();
      for(int i = 0; i < numplayers; i++)
	{
	  if(!(Collision(who, playershere[i])))
	    canmove = false;
	}
    }
  if(canmove)
    {
      theGame->Move(who, where);
      if(item)
	CanITake(who, where);
    }
  
  return canmove;
}

// Request to take the specified item 
void GameServer::CanITake( Player* who, Space* where) {
  UDPacket *rmitem;
  rmitem = new UDPacket();
  byte iteminfo[5];
  iteminfo[0] = (char)2;
  BaseItem *what;
  what = where->getItem();
  if((who->isAGhost()) != (what->IsPacItem()))
    {
      setCurrentRules(what->getItemRules(who));
      delete what;
      iteminfo[1] = (char)(where->getX());
      iteminfo[2] = (char)(where->getY());
      iteminfo[3] = (char)(where->getZ());
      iteminfo[4] = (char)(who->getPlayerID());
      rmitem->setData(iteminfo, 5);
      for(int i = 0; i < numclients; i++)
	{
	  rmitem->setAddress(clientads[i]);
	  socket->sendReliable(rmitem);
	}
    }
  return;
}

// Called after a player dies, checks type of player, possibly 
// number of lives, etc.  Possibly also used when a new player 
// enters the game. 
void GameServer::CanIRespawn( Player* who ) {

}

float GameServer::getTime(){
  return 0.0; // need to grab clock time of computer
}

// This will be a separate thread that will control the time 
// for synchronization with clients, as well as calling AI players' 
// decision functions. 
int GameServer::RunGame( void ) {
  // This loop needs to manage time, update positions of players, govern collisions and taking of items, and send updates to clients.

  // get system time and create deltatime
  float deltatime, oldtime;
  gametime = 0.0;
  oldtime = time(0);
  endgame = 0;
  int steps = 0;
  while(!endgame)
    {
      gametime = time(0);
      deltatime = gametime - oldtime;
      movePlayers(deltatime);
      if(steps >= 10)
	{
	  updateClients();
	  AIdecisions();
	  steps = 0;
	}
      else
	steps++;
      oldtime = gametime;
      if(gametime > gamelength)
	{
	  endgame = 1;
	  // inform the clients that the game is over
	}
    }
  return 0;
}

void GameServer::AIdecisions(){
  for(int i = 0; i < num_aigh; i++)
    {
      AIplayerlist[i]->decide();
    }
}

void GameServer::updateClients(){
  UDPacket *update;
  update = new UDPacket();
  byte pacinfo[((numplayers * 8) + 2)];
  int zero = 0;
  pacinfo[0] = (char)zero;
  assert(numplayers < 100);
  float fracdist = 0.0;
  int fdistone, fdisttwo, pid, xloc, yloc, zloc, dir, nextdir, fdist, pacindex;
  fdistone = fdisttwo = pid = xloc = yloc = zloc = dir = nextdir = fdist = pacindex = 0;
  //firstdigit = (numplayers / 10);
  //seconddigit = (numplayers % 10);
  pacinfo[1] = (char)numplayers;
  // pacinfo[2] = (char)seconddigit;
  pacindex = 2;
  Space *where;
  for(int i = 0; i < numplayers; i++)
    {
      pid = playerlist[i]->getPlayerID();
      assert(pid < 100);
      pacinfo[pacindex]= (char)pid;
      pacindex++;
      where = playerlist[i]->getSpace();
      xloc = where->getX();
      yloc = where->getY();
      zloc = where->getZ();
      pacinfo[pacindex]= (char)xloc;
      pacindex++;
      pacinfo[pacindex]= (char)yloc;
      pacindex++;
      pacinfo[pacindex]= (char)zloc;
      pacindex++;
      dir = playerlist[i]->getDir();
      nextdir = playerlist[i]->getIntended();
      pacinfo[pacindex]= (char)dir;
      pacindex++;
      pacinfo[pacindex]= (char)nextdir;
      pacindex++;
      fracdist = playerlist[i]->getFracDist();
      fracdist *= 10000;
      fdist = (int)fracdist;
      fdistone = fdist / 100;
      fdisttwo = fdist % 100;
      pacinfo[pacindex]= (char)fdistone;
      pacindex++;
      pacinfo[pacindex]= (char)fdisttwo;
      pacindex++;
    }
  update->setData(pacinfo, ((numplayers * 8) + 2));
  for(int i = 0; i < numclients; i++)
    {
      update->setAddress(clientads[i]);
      socket->sendReliable(update);
    }
}

void GameServer::movePlayers(float deltatime)
{
  Space* current;
  int curdir, newdir, moved, olddir;
  float fracdist;
  float distance;
  float* speedarray = currentMechanics->getSpeedArray();
  for(int i = 0; i < numplayers; i++)
    {
      moved = 0;
      fracdist = playerlist[i]->getFracDist();
      distance = deltatime * (speedarray[i]);
      fracdist += distance;
      if(fracdist >= 1)
	{
	  curdir = playerlist[i]->getDirection();
	  newdir = playerlist[i]->getIntended();
	  current = playerlist[i]->getSpace();
	  if(current->getNeighbor(newdir))
	    {
	      if(CanIMove(playerlist[i], current->getNeighbor(newdir)))
		{
		  moved = 1;
		}
	    }
	  if(!(moved))
	    {
	      if(current->getNeighbor(curdir))
		{
		  if(CanIMove(playerlist[i], current->getNeighbor(curdir)))
		    {
		      moved = 1;
		    }
		}
	    }
	  if(!(moved))
	    {
	      if(curdir == 1)
		olddir = 3;
	      else if(curdir == 2)
		olddir = 4;
	      else if(curdir == 3)
		olddir = 1;
	      else if(curdir == 4)
		olddir = 2;
	      else if(curdir == 5)
		olddir = 6;
	      else
		olddir = 5;
	      for(int j = 0; ((j < 7) && (!(moved))); j++)
		{
		  if((j != newdir) && (j != curdir) && (j != olddir))
		    {
		      if(current->getNeighbor(j))
			{
			  if(CanIMove(playerlist[i], current->getNeighbor(j)))
			    {
			      moved = 1;
			    }
			}
		    }
		}
	    }
	  if(!(moved))
	    {
	      if(current->getNeighbor(olddir))
		{
		  if(CanIMove(playerlist[i], current->getNeighbor(olddir)))
		    {
		      moved = 1;
		    }
		}
	    }
	  assert(moved);
	  fracdist -= 1.0;
	}
      playerlist[i]->setFracDist(fracdist);
    }
}
      
void GameServer::receivePacket(UDPacket *pack)
{
  int length = pack->getLength();
  int type = (int)(pack->getData(0));
  int whichplayer, whichdir, done, i;
  whichplayer = whichdir = done = i = 0;
  if(type == 1)
    {
      whichplayer = (int)(pack->getData(1));
      whichdir = (int)(pack->getData(2));
      while(!done)
	{
	  if(whichplayer == ((playerlist[i]->getPlayerID())))
	    {
	      playerlist[i]->setIntended(whichdir);
	      done = 1;
	    }
	  i++;
	}
    }
  // add stuff for initial connection, player quits, etc.

}
// Sets the current rule set pointer to gr. 
void GameServer::setCurrentRules( GameRules * gr ) {
  currentRules[numRules] = gr;
  numRules++;
}

// Makes the rules associated with the specified item the current 
// rules. 
void GameServer::invokeItemRules( BaseItem * bi, Player* eater ) {
  currentRules[numRules] = bi->getItemRules(eater);
  numRules++;
}

// Sets the game mode. This function does nothing if we're in 
// the middle of a game. 
void GameServer::setGameMode(int gametype ) {
  
}

// Returns the game mode. 
int GameServer::getGameMode( void ) {
  return mode;
}




